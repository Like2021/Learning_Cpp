# 常见算法

## 1. 归并排序`MergeSort`

### 动图演示

![img](/home/like/Like/sues/Learning_Cpp/Leetcode_record/常见算法/mergeSort.gif)

### 代码实现

```c++
void Merge(std::vector<int>& Array, int front, int mid, int end) {
  // 1.分成两个子序列
  std::vector<int> leftSubArray(Array.begin() + front, Array.begin() + mid + 1);
  std::vector<int> rightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);
  int idxLeft = 0, idxRight = 0;
  // 2.给两个子序列末尾插入最大值，保证实际的所有值都能遍历到
  leftSubArray.insert(leftSubArray.end(), numeric_limits<int>::max());
  rightSubArray.insert(rightSubArray.end(), numeric_limits<int>::max());
  // 3.依次保存两个子序列里的更小值
  for (int i = front; i <= end; ++i) {
    if (leftSubArray[idxLeft] < rightSubArray[idxRight]) {
      Array[i] = leftSubArray[idxLeft++];
    } else {
      Array[i] = rightSubArray[idxRight++];
    }
  }
}

void MergeSort(std::vector<int>& Array, int front, int end) {
  if (front >= end) return;
  int mid = (front + end) / 2;
  MergeSort(Array, front, mid);
  MergeSort(Array, mid + 1, end);
  Merge(Array, front, mid, end);
}
```



## 2. 快速排序`QuickSort`

### 动图演示

![img](/home/like/Like/sues/Learning_Cpp/Leetcode_record/常见算法/quickSort.gif)

### 代码实现

```c++
int Paritition(std::vector<int>& Array, int low, int high) {
  // 1.选取Array[low]为基准元素
  int pivot = Array[low];
  while (low < high) {
    // 2.先从右边开始，找第一个小于pivot的值
    while (low < high && Array[high] >= pivot) {
      --high;
    }
    // 3.将其移动到左边，与pivot换位置
    Array[low] = Array[high];
    // 4.再从左边开始，找地一个大于pivot的值
    while (low < high && Array[low] <= pivot) {
      ++low;
    }
    // 5.将其移动到右边，与pivot换位置
    Array[high] = Array[low];
  }  // 不断重复这个过程，直到low和high相遇
  // 6.将pivot放置到相遇的位置，返回相遇的位置作为基准元素的最终位置
  Array[low] = pivot;
  return low;
}

void QuickSort(std::vector<int>& Array, int low, int high) {
  if (low < high) {
    int pivot = Paritition(Array, low, high);
    QuickSort(Array, low, pivot - 1);
    QuickSort(Array, pivot + 1, high);
  }
}
```

