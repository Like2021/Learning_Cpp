# 6. 栈与队列

## 4. 有效括号

### 20. 有效括号（简单）

**题目：**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

**解题思路：**

三种情况如下

1. 字符串里左方向的括号多余
2. 括号没多余，但类型不匹配
3. 字符串里右方向的括号多余



};![20.有效括号](6栈与队列/20.有效括号.gif)

```c++
class Solution {
public:
    bool isValid(string s) {
        // 先判断字符串的长度奇偶性，奇数直接返回false
        if (s.size() % 2 != 0) return false;
        // 初始化一个栈
        stack<char> st;
        for (int i = 0; i < s.size(); i++)
        {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：匹配的过程中，发现栈里没有元素，说明右括号多余
            // 第二种情况：匹配的过程中，发现没有要匹配的字符
            else if (st.empty() || st.top() != s[i]) return false;
            // st.top() 与 s[i]相等，栈弹出元素
            else st.pop();
        }
        // 第一种情况：此时遍历完字符串，但栈不为空，说明左括号多余
        return st.empty();
    }
};
```

## 5. 删除字符串中所有相邻重复项

### 1047. 删除字符串中所有相邻重复项（简单）

**题目：**

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**解题思路：**

![1047.删除字符串中的所有相邻重复项](6栈与队列/1047.删除字符串中的所有相邻重复项.gif)

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        // 初始化容器
        stack<char> st;
        for (char str : s)
        {
            // 容器中为空或者字符与栈顶不相同，塞入字符
            if (st.empty() || str != st.top()) st.push(str);
            // 与栈顶字符相同，弹出栈顶字符
            else st.pop();
        }

        // 初始化字符串变量
        string result = "";
        while (!st.empty())  // 只有不为空就继续循环
        {
            result += st.top();
            st.pop();
        }
        // 由于栈先进后出的特性，翻转一下字符串
        reverse(result.begin(), result.end());
        return result;
    }
};
```

## 6. 逆波兰表达式求值

### 150. 逆波兰表达式求值（中等）

**题目：**给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**解题思路：**

1. 遍历字符串数组里的字符
2. 如果是运算符号，就取出之前的两个字符，并转换为数值，然后利用遍历出来的运算符号进行运算，最后把结果压入栈
3. 如果不是运算符号，就压入栈中
4. 遍历完之后，栈里的最后一个元素就是最终结果

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 初始化一个记录的栈
        stack<long long> st;
        // 遍历字符串
        for (int i = 0; i < tokens.size(); i++)
        {
            // 判断遍历出来的字符是运算符号
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")
            {
                // 取出栈顶元素
                long long num1 = st.top();
                // 弹出栈顶元素
                st.pop();
                
                long long num2 = st.top();
                st.pop();

                // 根据运算符号进行相应的运算，并把结果压入栈中
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            }
            // 遍历出来的字符不是运算符号，给它转个类型之后压入栈中
            else
            {
                st.push(stoll(tokens[i]));
            }
        }

        // 遍历完之后拿到最终结果
        int result = st.top();
        st.pop();
        return result;
    }
};
```

