# 回溯算法

## 1.回溯算法理论基础

作为纯暴力搜索，可以解决如下问题：

1. 组合问题

   组合是无序的。

2. 切割问题

3. 子集问题

4. 排列问题

   排列是有序的。

5. 棋盘问题



一般的伪代码：

```c++
void backTracking(para list)
{
    if (终止条件)
    {
        收集结果
        return;
    }
    for (集合的元素集)
    {
        处理节点
        递归函数
        回溯操作
    }
    return;
}
```



### 回溯三部曲

1. 递归函数的参数和返回值
2. 递归函数的终止条件
3. 确定单层搜索的逻辑



## 2/3.组合问题/组合优化

### 77. 组合（中等）

**题目：**

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。



**解法：**

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        // 定义两个容器
        vector<int> path;
        vector<vector<int>> result;
        // 递归调用
        backTracking(path, result, n, k, 1);
        return result;
    }
    
    void backTracking(vector<int> &path, vector<vector<int>> &result, int n, int k, int startIndex)
    {
        // 找到符合条件的结果
        if (path.size() == k)
        {
            // 将符合条件的结果记录下来
            result.push_back(path);
            return;
        }
        // 其实符合条件的集合位置最多到n - (k - path.size()) + 1，再往后就没必要遍历
        // for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)
        for (int i = startIndex; i <= n; i++)
        {
            // 记录遍历的元素
            path.push_back(i);
            // 进行递归
            backTracking(path, result, n, k, i + 1);
            // 回溯弹出尾部数据
            path.pop_back();
        }
    }
};
```



