# 7. 二叉树

## 1. 二叉树的理论基础

先序和中序能确定一个二叉数，

中序和后序能确定一个二叉数，

先序和后序不能。



定义：

```c++
struct TreeNode
{
    int val;  // 节点本身的值
    TreeNode* left;  // 左子节点
    TreeNode* right;  // 右子节点
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```



## 2/3. 二叉树的递归/迭代遍历

### 144. 二叉树的前序遍历（简单）

#### 递归法

递归算法遍历的顺序是：中左右！

```c++
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec)
    {
        if (cur == nullptr) return;

        // 前序遍历，中左右的顺序
        vec.push_back(cur->val);
        // 先递归左边的结点
        traversal1(cur->left, vec);
        // 再递归右边
        traversal1(cur->right, vec);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 迭代法

![二叉树前序遍历（迭代法）](7二叉树/二叉树前序遍历（迭代法）.gif)

这里需要注意，**栈的特性是先进后出，同时遍历压入栈的时候，不要压入空节点。**

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        // 初始化栈
        stack<TreeNode*> st;
        // 初始化记录结果的容器
        vector<int> result;

        if (root == nullptr) return result;
        // 压入根节点
        st.push(root);
        while (!st.empty())  // 栈为空时，结束
        {
            // 记录栈顶节点
            TreeNode* node = st.top();  // 第一次循环里是根节点
            // 弹出栈顶节点
            st.pop();
            // 记录栈顶节点的val
            result.push_back(node->val);
            // 根据先进后出的栈原理，在这先压入右节点
            if (node->right) st.push(node->right);  // 空节点不入栈
            // 再压入左节点
            if (node->left) st.push(node->left);
        }

        return result;
    }
};
```



### 94. 二叉树的中序遍历（简单）

#### 递归法

遍历顺序：左中右！

```c++
class Solution {
public:
    void travelsal(TreeNode* cur, vector<int>& vec)
    {
        if (cur == nullptr) return;

        // 中序遍历的顺序，左中右
        travelsal(cur->left, vec);
        vec.push_bask(cur->val);
        travelsal(cur->right, vec);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        travelsal(root, result);
        return result;
    }
};
```



#### 迭代法

两件事：

1. 处理节点储存元素，存放到vector中
2. 访问每个节点

然而中序遍历是左中右的顺序，但访问节点是从中间开始的，这也就导致了不能访问完接着处理。

![二叉树中序遍历（迭代法）](7二叉树/二叉树中序遍历（迭代法）.gif)



```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        // 初始化访问节点和存储值的容器
        vector<int> result;
        stack<TreeNode*> st;
        // 初始化一个辅助指针，来协助一起访问节点
        TreeNode* cur = root;

        while (cur != nullptr || !st.empty())
        {
            if (cur != nullptr)  // 上来直接用指针访问节点，一直到左边最底层
            {
                // 然后用栈来存放节点
                st.push(cur);
                // 更新cur，如果是底层节点的话，更新一下就变成NULL了
                cur = cur->left;
            }
            else
            {
                // 如果当前循环的cur是NULL那就意味着是底层节点或者其孩子节点已经弹出了
                // 这里记录栈顶节点，开始记录元素操作
                cur = st.top();
                st.pop();  // 别忘了弹出栈顶
                result.push_back(cur->val);
                // 记录好之后，更新cur的右节点
                cur = cur->right;
            }
        }
        return result;
    }
};
```



### 145. 二叉树的后序遍历（简单）

#### 递归法

遍历顺序是：左右中！

```c++
class Solution {
public:
    void traversal(TreeNode* cur, std::vector<int>& vec)
    {
        if (cur == nullptr) return;

        // 后序遍历，左右中的顺序
        traversal3(cur->left, vec);
        traversal3(cur->right, vec);
        vec.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```



#### 迭代法

![前序到后序](7二叉树/20200808200338924.png)

1. 先再前序遍历中修改左右访问节点的顺序，得到中右左的结果
2. 反转结果容器，变成左右中的结果，刚好是后序遍历的结果

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        // 初始化访问节点和存储值的容器
        vector<int> result;
        stack<TreeNode*> st;

        if (root == nullptr) return result;
        // 压入根节点
        st.push(root);
        while (!st.empty())
        {
            // 记录栈顶节点
            TreeNode* node = st.top();
            // 别忘了记录好后弹出
            st.pop();
            // 记录栈顶节点的val
            result.push_back(node->val);
            // 根据想要的中右左，在这里先压入左节点，先进后出
            if (node->left) st.push(node->left);
            if (node->right) st.push(node->right);
        }

        // 得到中右左的结果，反转一下
        reverse(result.begin(), result.end());

        return result;
    }
};
```



## 4. 二叉树的统一迭代法

以中序遍历为例，使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。

那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。

如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。



### 94. 二叉树的中序遍历（简单）

![中序遍历迭代（统一写法）](7二叉树/中序遍历迭代（统一写法）.gif)

**跟着上图理解下面的代码，后面的前序遍历和后序遍历思路与之一致。**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        // 定义一个存放结果的容器
        vector<int> result;
        // 定义一个用来遍历的容器
        stack<TreeNode*> st;
        // 先压入根节点
        if (root != nullptr) st.push(root);
        while (!st.empty())  // 如果st不为空，就一直循环
        {
            // 定义一个临时节点，记录栈顶节点
            TreeNode* node = st.top();
            // 判断临时节点记录的是否为空节点
            if (node != nullptr)  // 如果不为空节点
            {
                st.pop();  // 先弹出节点，避免重复操作
                // 接下来现依次加入右中左节点，因为先进后出
                if (node->right) st.push(node->right);  // 添加右节点，空节点不入栈
                // 添加中节点
                st.push(node);
                // 核心部分，因为中节点访问过，但是还没处理，我们这里加入空节点进行标记
                st.push(nullptr);
                if (node->left) st.push(node->left);  // 添加左节点，空节点不入栈
            }
            else
            {
                // 只有遇到空节点的时候，才将下一个节点放进结果集
                // 1.先弹出空节点
                st.pop();
                // 2.对空节点的下一个节点进行操作
                node = st.top();
                st.pop();
                result.push_back(node->val);  // 放入结果集
            }
        }
        return result;
    }
};
```



### 144. 二叉树的前序遍历（简单）

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        // 定义结果集
        vector<int> result;
        // 定义栈
        stack<TreeNode*> st;
        // 压入根节点
        if (root != nullptr) st.push(root);
        while (!st.empty())
        {
            // 只要栈不为空，就一直循环遍历
            // 先定义一个临时节点，用来记录栈顶节点
            TreeNode* node = st.top();
            // 根据此时的栈顶节点，来判断是否放入结果集
            if (node != nullptr)
            {
                // node不等于null说明没有标记
                // 那就先弹出这个节点
                st.pop();
                // 前序遍历是中左右，那么接下来就是依次存放右左中
                // 存放右节点
                if (node->right != nullptr) st.push(node->right);
                // 存放左节点
                if (node->left != nullptr) st.push(node->left);
                // 关键在于存放中节点
                st.push(node);
                // 再存放一个null进行标记
                st.push(nullptr);
            }
            else
            {
                // 碰到空节点，说明遇到标记了，下一个节点就是要放入结果集的
                // 1.先弹出空节点
                st.pop();
                // 2.记录栈顶节点
                node = st.top();
                // 3.弹出栈顶节点
                st.pop();
                // 4.存放到结果集
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```



### 145. 二叉树的后序遍历（简单）

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        // 先定义两个容器，记录结果和遍历节点
        vector<int> result;
        stack<TreeNode*> st;
        // 先压入空节点
        if (root != nullptr) st.push(root);
        while (!st.empty())  // 栈不为空，就一直遍历
        {
            // 定义临时节点
            TreeNode* node = st.top();
            // 判断是否为null标记
            if (node != nullptr)
            {
                // 如果不是标记点，就根据遍历方式，存放节点
                // 这里后序遍历，再结合先进后出的特性，依次放入中右左
                st.pop();
                st.push(node);
                st.push(nullptr);
                if (node->right != nullptr) st.push(node->right);
                if (node->left != nullptr) st.push(node->left);
            }
            else
            {
                // 遇到标记，那就处理下一个节点
                st.pop();
                node = st.top();
                st.pop();
                // 将节点存放的数据，放入结果集
                result.push_back(node->val);
            }
        }
        return result;
    }
};
```



## 5. 二叉树的层序遍历

### 102. 二叉树的层序遍历（中等）

**题目：**

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![BFS-and-DFS-Algorithms.png](7二叉树/75fc42a2cfacf6e41a86b34b1861d2cdcd2965b20d8ebc0a6dcc41bb1fbcea31-BFS-and-DFS-Algorithms.png)



#### 迭代法

**解题思路：**

![102二叉树的层序遍历](7二叉树/102二叉树的层序遍历.gif)

1. 利用队列`queue`记录访问到的数据
2. 利用一个辅助容器`vector`来记录每一层的数据
3. 最后利用一个容器`vector`记录总的数据

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        // 初始化一个队列
        queue<TreeNode*> que;
        // 压入根节点
        if (root != NULL) que.push(root);
        // 初始化一个记录结果的容器
        // 返回二维数组
        vector<vector<int>> result;
        while (!que.empty())
        {
            // 记录队列大小
            int size = que.size();
            // 记录每一层数据的容器，一维数组
            vector<int> vec;

            for (int i = 0; i < size; i++)
            {
                // 拿到队列的头节点
                TreeNode* node = que.front();
                que.pop();

                // 获得节点的值
                vec.push_back(node->val);
                // 根据先左后右的方式，在队列中添加当前节点的孩子节点
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            // 记录一维数组
            result.push_back(vec);
        }
        return result;
    }
};
```



#### 递归法

**解题思路：**

1. 遍历左树
2. 遍历右树

```c++
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        // 如果深度和层级相等，就压入一个vector
        if (result.size() == depth) result.push_back(vector<int>());
        // 在相应的depth中压入当前节点的数据
        result[depth].push_back(cur->val);
        // 递归，先左后右
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }

    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```



## 6. 翻转二叉树

### 226. 翻转二叉树（简单）

**题目：**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

#### 递归法

![翻转二叉树](7二叉树/翻转二叉树.gif)

**解题思路：**

利用前序遍历，先反转左右孩子节点，然后在反转左树，最后反转右树。

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



#### 迭代法

其实迭代法这里已经不是很关心放入栈的顺序了，因为不用记录节点数据，只需要翻转孩子节点就行了。

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return root;
        // 定义遍历的栈
        stack<TreeNode*> st;
        // 先压入根节点
        st.push(root);
        while (!st.empty())
        {
            // 定义临时节点
            TreeNode* node = st.top();  // 中
            st.pop();
            swap(node->left, node->right);  // 交换两个孩子节点
            // 将交换后的孩子节点放入栈中
            if (node->left) st.push(node->left);
            if (node->right) st.push(node->right);
        }
        return root;
    }
};
```



#### 统一迭代法

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // 定义遍历的栈
        stack<TreeNode*> st;
        // 先压入根节点
        if (root != nullptr) st.push(root);
        while (!st.empty())
        {
            // 定义临时节点
            TreeNode* node = st.top();
            // 判断是否有null标记
            if (node != nullptr)
            {
                st.pop();  // 先弹出，防止重复操作
                // 依次放入节点  右左中
                if (node->right) st.push(node->right);
                if (node->left) st.push(node->left);
                st.push(node);
                st.push(nullptr);
            }
            else
            {
                // 翻转的逻辑
                // 1.先弹出null
                st.pop();
                // 2.拿出下一个节点
                node = st.top();
                st.pop();
                // 3.翻转
                swap(node->left, node->right);
            }
        }
        return root;
    }
};
```



## 8. 对称二叉树

### 101. 对称二叉树（简单）

**题目：**

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**解题思路：**

![101. 对称二叉树1](7二叉树/20210203144624414.png)



#### 递归法

```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right)
    {
        // 首先排除空节点的一些情况，
        // 即左右节点有一个是空的就直接返回false，但如果均为空则说明是对称的
        if (left == nullptr && right != nullptr) return false;
        else if (left != nullptr && right == nullptr) return false;
        else if (left == nullptr && right == nullptr) return true;
        // 再排除左右节点数值不同的情况
        else if (left->val != right->val) return false;

        // 接下来就是处理左右节点不为空，且值相同的情况
        // 递归判断 外侧和内侧子树的情况
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        // 最后，如果均为true，才是对称
        bool isSame = outside && inside;
        return isSame;
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return compare(root->left, root->right);
    }
};
```



#### 迭代法

**解题思路：**

这里可以用队列来判断左子树和右子树的内侧和外侧是否相等，

![101.对称二叉树](7二叉树/101.对称二叉树.gif)

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        // 首先，如果是空树，直接返回true
        if (root == nullptr) return true;
        // 定义一个队列
        queue<TreeNode*> que;
        // 将左右节点放入
        que.push(root->left);
        que.push(root->right);
        // 判断是否是对称
        while (!que.empty())
        {
            // 定义来个临时节点
            TreeNode* leftNode = que.front();
            que.pop();
            TreeNode* rightNode = que.front();
            que.pop();
            // 如果左右皆为空，说明是对称的，继续下一个遍历
            if (leftNode == nullptr && rightNode == nullptr)
            {
                continue;
            }
            // 如果有一个节点不为空，或者都不为空但数值不一样，那就不对称，返回false
            if (!leftNode || !rightNode || (leftNode->val != rightNode->val))
            {
                return false;
            }
            // 接下来就是处理左右子树了
            // 外侧节点
            que.push(leftNode->left);  // 加入左节点的左孩子
            que.push(rightNode->right);  // 加入右节点的右孩子
            // 内侧节点
            que.push(leftNode->right);
            que.push(rightNode->left);
        }
        return true;
    }
};
```



## 9. 二叉树的最大深度

### 104. 二叉树的最大深度（简单）

**题目：**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**解题思路：**

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。



#### 递归法

1. 用后序遍历（左右中）来计算树的高度。

先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。

```c++
class Solution {
public:
    int getHeight(TreeNode* node)
    {
        if (node == nullptr) return 0;
        // 后序遍历，求根节点的高度，就是二叉树的最大深度
        int leftheight = getHeight(node->left);  // 左
        int rightheight = getHeight(node->right);  // 右
        // 这才是处理逻辑
        // 当前节点的高度等于左右子树的高度最大值+1
        int height = 1 + max(leftheight, rightheight);  // 中
        return height;
    }

    int maxDepth(TreeNode* root) {
        int depth = getHeight(root);
        return depth;
    }
};
```



2. 使用前序求深度**（先留着，与回溯有关，暂时看不懂）**



#### 迭代法

使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        // 定义一个记录深度的变量
        int depth = 0;
        // 定义一个队列来遍历节点
        queue<TreeNode*> que;
        // 先压入根节点
        que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            depth++;  // 记录深度
            for (int i = 0; i < size; i++)
            {
                // 先记录队列的头节点
                TreeNode* node = que.front();
                // 别忘了弹出
                que.pop();
                // 再压入当前节点的左右节点
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```



## 10. 二叉树的最小深度

### 111. 二叉树的最小深度（简单）

**题目：**

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

*说明: 叶子节点是指没有子节点的节点。*



#### 递归法

后序遍历：

```c++
class Solution {
public:
    int getHeight(TreeNode* node)
    {
        // 结束条件，如果遍历到最下面的null，说明高度是0,返回
        if (node == nullptr) return 0;
        // 先求左右子树的最小高度
        int leftHeight = getHeight(node->left);
        int rightHeight = getHeight(node->right);
        // 然后写处理逻辑，也就是中
        // 如果左右子树有一个为null
        if (node->left == nullptr && node->right != nullptr)
        {
            return 1 + rightHeight;
        }
        if (node->right == nullptr && node->left != nullptr)
        {
            return 1 + leftHeight;
        }
        // 左右子树都不为空
        int height = 1 + min(leftHeight, rightHeight);
        return height;
    }

    int minDepth(TreeNode* root) {
        // 求根节点的最小高度，就是最小深度
        int depth = getHeight(root);
        return depth;
    }
};
```



#### 迭代法

层序遍历：

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        // 定义记录深度的变量和遍历的队列
        int depth = 0;
        queue<TreeNode*> que;
        // 先压入根节点
        que.push(root);
        // 如果队列不为空，就一直遍历
        while (!que.empty())
        {
            // 记录当前层的节点个数，并更新深度
            int size = que.size();
            depth++;
            for (int i = 0; i < size; i++)
            {
                // 再将当前层的节点进行记录和压入左右孩子节点
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                // 如果碰到叶子节点，说明孩子节点都为空，那么返回深度
                if (!node->left && !node->right) return depth;
            }
        }
        return depth;
    }
};
```



## 11. 完全二叉树的节点个数

### 222. 完全二叉树的节点个数（中等）

**题目：**

给出一个完全二叉树，求出该树的节点个数。

#### 普通二叉树解法

递归法：

```c++
class Solution {
public:
    int getNums(TreeNode* node)
    {
        // 后序遍历
        // 先写个终止条件
        if (node == nullptr) return 0;
        // 递归得到左右子树的数量
        int leftNums = getNums(node->left);  // 左
        int rightNums = getNums(node->right);  // 右
        // 关键处理逻辑，节点数量等于左右子树的节点数加上当前节点，即+1
        int nums = 1 + leftNums + rightNums;  // 中
        return nums;
    }

    int countNodes(TreeNode* root) {
        return getNums(root);
    }
};
```



迭代法：

用层序遍历

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        // 定义一个队列遍历节点
        queue<TreeNode*> que;
        // 压入头节点
        if (root != nullptr) que.push(root);
        int result = 0;
        while (!que.empty())
        {
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                result++;  // 记录节点数量
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```





#### 完全二叉树解法

完全二叉树定义

![img](7二叉树/20200920221638903-20230310123444151.png)

递归法：

```c++
class Solution {
public:
    int getNums(TreeNode* node)
    {
        // 终止条件还有一个遇到满二叉树的时候
        if (node == nullptr) return 0;
        // 定义两个指针和两个记录深度的变量
        TreeNode* left = node->left;
        TreeNode* right = node->right;
        int leftDepth = 0;
        int rightDepth = 0;
        // 接下来寻找满二叉数，计算左右深度
        while (left)
        {
            left = left->left;
            leftDepth++;
        }
        while (right)
        {
            right = right->right;
            rightDepth++;
        }
        // 判断左右深度是否相等
        // 相等说明是一个满二叉树，节点数就是2的深度次方-1
        // 2<<1指2的1次方
        if (rightDepth == leftDepth) return (2<<leftDepth) - 1;
        // 然后写单层递归逻辑
        int leftNums = getNums(node->left);  // 左
        int rightNums = getNums(node->right);  // 右
        int nums = leftNums + rightNums + 1;  // 中
        return nums;
    }

    int countNodes(TreeNode* root) {
        return getNums(root);
    }
};
```









